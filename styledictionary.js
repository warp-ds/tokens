import StyleDictionary from "style-dictionary";
import fs from "fs";
import path from "path";

// Custom transform to preserve hex values with alpha exactly as they appear in the JSON
StyleDictionary.registerTransform({
  name: 'color/hexAlpha',
  type: 'value',
  matcher: function(prop) {
    return prop.attributes.category === 'color';
  },
  transformer: function(prop) {
    return prop.value; // Use the hex value exactly as it appears in the JSON
  }
});

// Register combined-swiftui-uikit-color-format for primitive colors
StyleDictionary.registerFormat({
  name: 'combined-swiftui-uikit-color-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Generating brand colors for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Colors.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI and UIKit colors based on the brand's primitive colors
    const swiftUIColorBlock = dictionary.allProperties.map(token => {
      const nameParts = token.path.filter(part => part.toLowerCase() !== 'color');
      const name = nameParts.join('').replace(/-/g, ''); // Remove dashes and combine

      return `    static let ${name} = Color(hex: "${token.value}")`;
    }).join('\n');

    const uiColorBlock = dictionary.allProperties.map(token => {
      const nameParts = token.path.filter(part => part.toLowerCase() !== 'color');
      const name = nameParts.join('').replace(/-/g, ''); // Remove dashes and combine

      return `    static let ${name} = UIColor(hex: "${token.value}")`;
    }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}Colors {
${swiftUIColorBlock}
}

struct ${brandName}UIColors {
${uiColorBlock}
}
`;
  }
});

// Register token-provider-swift-format for iOS TokenProvider generation
StyleDictionary.registerFormat({
  name: 'token-provider-swift-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Inside token-provider-swift-format formatter for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Tokens.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI light colors
    const swiftUIColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts

        return `    var ${name}: Color { get }`;
      }).join('\n');

    // Generate UIKit light colors
    const uiColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts

        return `    var ${name}: UIColor { get }`;
      }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
public protocol TokenProvider {
${swiftUIColorBlock}
}

public protocol UITokenProvider {
${uiColorBlock}
}
`;
  }
});

// Register tokens-light-swift-format for iOS light token generation
StyleDictionary.registerFormat({
  name: 'tokens-light-swift-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Inside tokens-light-swift-format formatter for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Tokens.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI light colors
    const swiftUIColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    public var ${name}: Color { ${brandName.replace('Light', '')}${value} }`;
      }).join('\n');

    // Generate UIKit light colors
    const uiColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    public var ${name}: UIColor { ${brandName.replace('Light', '')}UI${value} }`;
      }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}TokenProvider: TokenProvider {
${swiftUIColorBlock}
}

struct ${brandName}UITokenProvider: UITokenProvider {
${uiColorBlock}
}`;
  }
});

// Register tokens-dark-swift-format for iOS dark token generation
StyleDictionary.registerFormat({
  name: 'tokens-dark-swift-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Inside tokens-dark-swift-format formatter for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Tokens.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI dark colors
    const swiftUIColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    public var ${name}: Color { ${brandName.replace('Dark', '')}${value} }`;
      }).join('\n');

    // Generate UIKit dark colors
    const uiColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep semantic tokens
      .map(token => {
        let name = toCamelCase(token.path.slice(2).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    public var ${name}: UIColor { ${brandName.replace('Dark', '')}UI${value} }`;
      }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}TokenProvider: TokenProvider {
${swiftUIColorBlock}
}

struct ${brandName}UITokenProvider: UITokenProvider {
${uiColorBlock}
}`;
  }
});

// Register colors-light-swift-format for iOS light color generation
StyleDictionary.registerFormat({
  name: 'colors-light-swift-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Inside colors-light-swift-format formatter for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Colors.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI light colors
    const swiftUIColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep component colors
      .map(token => {
        let name = toCamelCase(token.path.slice(1).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    var ${name}: Color { ${brandName.replace('Light', '')}${value} }`;
      }).join('\n');

    // Generate UIKit light colors
    const uiColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep component colors
      .map(token => {
        let name = toCamelCase(token.path.slice(1).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    var ${name}: UIColor { ${brandName.replace('Light', '')}UI${value} }`;
      }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}ColorProvider {
${swiftUIColorBlock}
}

struct ${brandName}UIColorProvider {
${uiColorBlock}
}`;
  }
});

// Register colors-dark-swift-format for iOS dark color generation
StyleDictionary.registerFormat({
  name: 'colors-dark-swift-format',
  formatter: function({ dictionary, file, options }) {
    console.log(`Inside colors-dark-swift-format formatter for ${file.destination}`);

    const brandName = file.destination.split('/').pop().replace('Colors.swift', ''); // Extract brand name from the file path

    // Generate SwiftUI dark colors
    const swiftUIColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep component colors
      .map(token => {
        let name = toCamelCase(token.path.slice(1).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    var ${name}: Color { ${brandName.replace('Dark', '')}${value} }`;
      }).join('\n');

    // Generate UIKit dark colors
    const uiColorBlock = dictionary.allProperties
      .filter(token => !token.path[0].startsWith('color')) // Exclude primitive colors, only keep component colors
      .map(token => {
        let name = toCamelCase(token.path.slice(1).join('-')).replace('Default', ''); // Convert to camelCase, removing first two parts
        let value = transformValue(token.original.value)

        return `    var ${name}: UIColor { ${brandName.replace('Dark', '')}UI${value} }`;
      }).join('\n');

    return `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}ColorProvider {
${swiftUIColorBlock}
}

struct ${brandName}UIColorProvider {
${uiColorBlock}
}`;
  }
});

function transformValue(value) {
  // Remove curly braces and split by dots
  let parts = value.replace('{', '').replace('}', '').split('.');

  // Replace 'color' with 'Colors' and uppercase the first letter of the first part
  if (parts[0].toLowerCase() === 'color') {
    parts[0] = 'Colors';
  } else {
    parts[0] = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
  }

  // Remove the second dot (combine the second and third parts, if they exist)
  if (parts.length > 2) {
    parts[1] = parts[1] + parts[2];  // Combine the second and third parts
    parts.splice(2, 1);  // Remove the third part (dot removal)
  }

  // Join the parts back together with a dot
  return parts.join('.');
}

// Helper function to convert dashed and lowercased names to camelCase
function toCamelCase(str) {
  return str
    .split(/[-_]/g) // Split by dashes or underscores
    .map((word, index) => index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of every word except the first
    .join(''); // Join the words together to form a camelCase string
}

// Function to generate iOS-specific primitive colors for each brand
function generateColorsForIOS() {
  const tokensPath = "./tokens";
  const outputFolder = `output/ios/Brands/`; // Folder for iOS brand colors

  // Create output folder for iOS brand colors
  if (!fs.existsSync(outputFolder)) {
    fs.mkdirSync(outputFolder, { recursive: true });
    console.log(`Created output folder: ${outputFolder}`);
  }

  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  // Create a set to track unique brand names (e.g., 'finn', 'blocket')
  const uniqueBrands = new Set(
    brandModes.map((brandMode) => brandMode.split("-")[0])
  );

  uniqueBrands.forEach((brand) => {
    console.log(`Processing colors for brand: ${brand}`);

    const tokenFilePath = path.join(tokensPath, `${brand}-light`, "colors.json");

    // Check if colors.json exists before proceeding
    if (!fs.existsSync(tokenFilePath)) {
      console.error(`colors.json not found for ${brand}`);
      return; // Skip this brand if colors.json does not exist
    }

    try {
      const iosConfig = {
        source: [tokenFilePath],
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: outputFolder, // Trailing slash ensures correct file paths
            files: [
              {
                destination: `${brand.charAt(0).toUpperCase() + brand.slice(1)}Colors.swift`,
                format: "combined-swiftui-uikit-color-format",
                className: `${brand.charAt(0).toUpperCase() + brand.slice(1)}Colors`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"] // Use custom hexAlpha transform
          },
        },
      };

      const sd = StyleDictionary.extend(iosConfig);
      sd.buildPlatform('ios');
      console.log(`Successfully built iOS primitive colors for ${brand} in ${outputFolder}`);
    } catch (error) {
      console.error(`Error building iOS primitive colors for ${brand}: ${error.message}`);
    }
  });
}

// Function to generate iOS-specific TokenProvider
function generateTokenProviderForIOS() {
  const tokensPath = "./tokens";
  const iosTokensFolder = `output/ios/Tokens/`;  // Folder for iOS tokens

  // Create output folder for Tokens
  if (!fs.existsSync(iosTokensFolder)) {
    fs.mkdirSync(iosTokensFolder, { recursive: true });
    console.log(`Created output folder: ${iosTokensFolder}`);
  }

  const brandModes = fs
  .readdirSync(tokensPath)
  .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

// Create a set to track unique brand names (e.g., 'finn', 'blocket')
const uniqueBrands = new Set(
  brandModes.map((brandMode) => brandMode.split("-")[0])
);

uniqueBrands.forEach((brand) => {
    console.log(`Processing tokens for TokenProvider`);

    const lightTokenFilePath = path.join(tokensPath, `${brand}-light`, "semantic.json");
    const colorFilePath = path.join(tokensPath, `${brand}-light`, "colors.json"); // Load the color file for reference resolution

    // Skip this brand if semantic.json files or colors.json are missing
    if (!fs.existsSync(lightTokenFilePath) || !fs.existsSync(colorFilePath)) {
      console.error(`semantic.json or colors.json not found for ${brand}`);
      return; // Skip this brand if semantic.json or colors.json doesn't exist
    }

    try {
      console.log(`Reading light token file: ${lightTokenFilePath}`);
      const lightTokens = JSON.parse(fs.readFileSync(lightTokenFilePath));
      console.log(`Reading colors file: ${colorFilePath}`);
      const colorTokens = JSON.parse(fs.readFileSync(colorFilePath));

      const iosTokensConfig = {
        source: [lightTokenFilePath, colorFilePath], // Include colors.json in source to resolve references
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: iosTokensFolder,
            files: [
              {
                destination: `TokenProvider.swift`,
                format: "token-provider-swift-format",
                className: `TokenProvider`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"]
          },
        },
      };

      const sdTokens = StyleDictionary.extend(iosTokensConfig);
      sdTokens.buildPlatform('ios');
      console.log(`Successfully built iOS tokens for ${brand} in ${iosTokensFolder}`);
    } catch (error) {
      console.error(`Error building iOS tokens for ${brand}: ${error.message}`);
    }
  });
}

// Function to generate iOS-specific light tokens for each brand
function generateLightTokensForIOS() {
  const tokensPath = "./tokens";
  const iosTokensFolder = `output/ios/Tokens/`;  // Folder for iOS tokens

  // Create output folder for Tokens
  if (!fs.existsSync(iosTokensFolder)) {
    fs.mkdirSync(iosTokensFolder, { recursive: true });
    console.log(`Created output folder: ${iosTokensFolder}`);
  }

  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  // Create a set to track unique brand names (e.g., 'finn', 'blocket')
  const uniqueBrands = new Set(
    brandModes.map((brandMode) => brandMode.split("-")[0])
  );

  uniqueBrands.forEach((brand) => {
    console.log(`Processing tokens for brand: ${brand}`);

    const lightTokenFilePath = path.join(tokensPath, `${brand}-light`, "semantic.json");
    const colorFilePath = path.join(tokensPath, `${brand}-light`, "colors.json"); // Load the color file for reference resolution

    // Skip this brand if semantic.json files or colors.json are missing
    if (!fs.existsSync(lightTokenFilePath) || !fs.existsSync(colorFilePath)) {
      console.error(`semantic.json or colors.json not found for ${brand}`);
      return; // Skip this brand if semantic.json or colors.json doesn't exist
    }

    try {
      console.log(`Reading light token file: ${lightTokenFilePath}`);
      const lightTokens = JSON.parse(fs.readFileSync(lightTokenFilePath));
      console.log(`Reading colors file: ${colorFilePath}`);
      const colorTokens = JSON.parse(fs.readFileSync(colorFilePath));

      const iosTokensConfig = {
        source: [lightTokenFilePath, colorFilePath], // Include colors.json in source to resolve references
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: iosTokensFolder,
            files: [
              {
                destination: `${brand.charAt(0).toUpperCase() + brand.slice(1)}LightTokens.swift`,
                format: "tokens-light-swift-format",
                className: `${brand.charAt(0).toUpperCase() + brand.slice(1)}LightTokens`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"]
          },
        },
      };

      const sdTokens = StyleDictionary.extend(iosTokensConfig);
      sdTokens.buildPlatform('ios');
      console.log(`Successfully built iOS tokens for ${brand} in ${iosTokensFolder}`);
    } catch (error) {
      console.error(`Error building iOS tokens for ${brand}: ${error.message}`);
    }
  });
}

// Function to generate iOS-specific dark tokens for each brand
function generateDarkTokensForIOS() {
  const tokensPath = "./tokens";
  const iosTokensFolder = `output/ios/Tokens/`;  // Folder for iOS tokens

  // Create output folder for Tokens
  if (!fs.existsSync(iosTokensFolder)) {
    fs.mkdirSync(iosTokensFolder, { recursive: true });
    console.log(`Created output folder: ${iosTokensFolder}`);
  }

  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  // Create a set to track unique brand names (e.g., 'finn', 'blocket')
  const uniqueBrands = new Set(
    brandModes.map((brandMode) => brandMode.split("-")[0])
  );

  uniqueBrands.forEach((brand) => {
    console.log(`Processing tokens for brand: ${brand}`);

    const darkTokenFilePath = path.join(tokensPath, `${brand}-dark`, "semantic.json");
    const colorFilePath = path.join(tokensPath, `${brand}-light`, "colors.json"); // Load the color file for reference resolution

    // Skip this brand if semantic.json files or colors.json are missing
    if (!fs.existsSync(darkTokenFilePath) || !fs.existsSync(colorFilePath)) {
      console.error(`semantic.json or colors.json not found for ${brand}`);
      return; // Skip this brand if semantic.json or colors.json doesn't exist
    }

    try {
      console.log(`Reading dark token file: ${darkTokenFilePath}`);
      const darkTokens = JSON.parse(fs.readFileSync(darkTokenFilePath));
      console.log(`Reading colors file: ${colorFilePath}`);
      const colorTokens = JSON.parse(fs.readFileSync(colorFilePath));

      const iosTokensConfig = {
        source: [darkTokenFilePath, colorFilePath], // Include colors.json in source to resolve references
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: iosTokensFolder,
            files: [
              {
                destination: `${brand.charAt(0).toUpperCase() + brand.slice(1)}DarkTokens.swift`,
                format: "tokens-dark-swift-format",
                className: `${brand.charAt(0).toUpperCase() + brand.slice(1)}DarkTokens`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"]
          },
        },
      };

      const sdTokens = StyleDictionary.extend(iosTokensConfig);
      sdTokens.buildPlatform('ios');
      console.log(`Successfully built iOS tokens for ${brand} in ${iosTokensFolder}`);
    } catch (error) {
      console.error(`Error building iOS tokens for ${brand}: ${error.message}`);
    }
  });
}

// Function to generate iOS-specific light colors for each brand
function generateLightColorsForIOS() {
  const tokensPath = "./tokens";
  const iosTokensFolder = `output/ios/`;  // Folder for iOS

  // Create output folder for Colors
  if (!fs.existsSync(iosTokensFolder)) {
    fs.mkdirSync(iosTokensFolder, { recursive: true });
    console.log(`Created output folder: ${iosTokensFolder}`);
  }

  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  // Create a set to track unique brand names (e.g., 'finn', 'blocket')
  const uniqueBrands = new Set(
    brandModes.map((brandMode) => brandMode.split("-")[0])
  );

  uniqueBrands.forEach((brand) => {
    console.log(`Processing colors for brand: ${brand}`);

    const lightColorFilePath = path.join(tokensPath, `${brand}-light`, "components.json");
    const lightTokenFilePath = path.join(tokensPath, `${brand}-light`, "semantic.json");
    const colorFilePath = path.join(tokensPath, `${brand}-light`, "colors.json"); // Load the color file for reference resolution

    // Skip this brand if semantic.json or semantic.json or colors.json files are missing
    if (!fs.existsSync(lightColorFilePath) || !fs.existsSync(lightTokenFilePath) || !fs.existsSync(colorFilePath)) {
      console.error(`components.json or semantic.json or colors.json not found for ${brand}`);
      return; // Skip this brand if components.json or semantic.json or colors.json doesn't exist
    }

    try {
      console.log(`Reading light color file: ${lightColorFilePath}`);
      const lightColors = JSON.parse(fs.readFileSync(lightColorFilePath));
      console.log(`Reading light token file: ${lightTokenFilePath}`);
      const lightTokens = JSON.parse(fs.readFileSync(lightTokenFilePath));
      console.log(`Reading colors file: ${colorFilePath}`);
      const colorTokens = JSON.parse(fs.readFileSync(colorFilePath));

      const iosColorsConfig = {
        source: [lightColorFilePath, lightTokenFilePath, colorFilePath], // Include colors.json in source to resolve references
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: iosTokensFolder,
            files: [
              {
                destination: `${brand.charAt(0).toUpperCase() + brand.slice(1)}LightColors.swift`,
                format: "colors-light-swift-format",
                className: `${brand.charAt(0).toUpperCase() + brand.slice(1)}LightColors`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"]
          },
        },
      };

      const sdTokens = StyleDictionary.extend(iosColorsConfig);
      sdTokens.buildPlatform('ios');
      console.log(`Successfully built iOS colors for ${brand} in ${iosTokensFolder}`);
    } catch (error) {
      console.error(`Error building iOS colors for ${brand}: ${error.message}`);
    }
  });
}

// Function to generate iOS-specific dark colors for each brand
function generateDarkColorsForIOS() {
  const tokensPath = "./tokens";
  const iosTokensFolder = `output/ios/`;  // Folder for iOS

  // Create output folder for Colors
  if (!fs.existsSync(iosTokensFolder)) {
    fs.mkdirSync(iosTokensFolder, { recursive: true });
    console.log(`Created output folder: ${iosTokensFolder}`);
  }

  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  // Create a set to track unique brand names (e.g., 'finn', 'blocket')
  const uniqueBrands = new Set(
    brandModes.map((brandMode) => brandMode.split("-")[0])
  );

  uniqueBrands.forEach((brand) => {
    console.log(`Processing colors for brand: ${brand}`);

    const darkColorFilePath = path.join(tokensPath, `${brand}-dark`, "components.json");
    const darkTokenFilePath = path.join(tokensPath, `${brand}-dark`, "semantic.json");
    const colorFilePath = path.join(tokensPath, `${brand}-dark`, "colors.json"); // Load the color file for reference resolution

    // Skip this brand if semantic.json or semantic.json or colors.json files are missing
    if (!fs.existsSync(darkColorFilePath) || !fs.existsSync(darkTokenFilePath) || !fs.existsSync(colorFilePath)) {
      console.error(`components.json or semantic.json or colors.json not found for ${brand}`);
      return; // Skip this brand if components.json or semantic.json or colors.json doesn't exist
    }

    try {
      console.log(`Reading dark color file: ${darkColorFilePath}`);
      const darkColors = JSON.parse(fs.readFileSync(darkColorFilePath));
      console.log(`Reading dark token file: ${darkTokenFilePath}`);
      const darkTokens = JSON.parse(fs.readFileSync(darkTokenFilePath));
      console.log(`Reading colors file: ${colorFilePath}`);
      const colorTokens = JSON.parse(fs.readFileSync(colorFilePath));

      const iosColorsConfig = {
        source: [darkColorFilePath, darkTokenFilePath, colorFilePath], // Include colors.json in source to resolve references
        platforms: {
          ios: {
            transformGroup: "ios-swift",
            buildPath: iosTokensFolder,
            files: [
              {
                destination: `${brand.charAt(0).toUpperCase() + brand.slice(1)}DarkColors.swift`,
                format: "colors-dark-swift-format",
                className: `${brand.charAt(0).toUpperCase() + brand.slice(1)}DarkColors`,
              }
            ],
            transforms: ["attribute/cti", "name/cti/pascal", "color/hexAlpha"]
          },
        },
      };

      const sdTokens = StyleDictionary.extend(iosColorsConfig);
      sdTokens.buildPlatform('ios');
      console.log(`Successfully built iOS colors for ${brand} in ${iosTokensFolder}`);
    } catch (error) {
      console.error(`Error building iOS colors for ${brand}: ${error.message}`);
    }
  });
}

// Function to combine LightTokens and DarkTokens files (both SwiftUI and UIKit)
function combineTokenProviders() {
  const outputFolder = "./output/ios/Tokens/";  // Folder containing the token files

  // Log all the files inside the folder
  const allFiles = fs.readdirSync(outputFolder);
  console.log(`Files in ${outputFolder}:`, allFiles);

  // Filter the files that end with LightTokens.swift
  const tokenFiles = allFiles.filter(file => file.endsWith("LightTokens.swift"));

  // Log how many files were found
  console.log(`Found ${tokenFiles.length} LightTokens files in ${outputFolder}`);

  tokenFiles.forEach(lightFile => {
    const brandName = lightFile.replace("LightTokens.swift", "");  // Extract the brand name
    const darkFile = `${brandName}DarkTokens.swift`;  // Corresponding dark token provider file

    const lightFilePath = path.join(outputFolder, lightFile);
    const darkFilePath = path.join(outputFolder, darkFile);

    console.log(`Processing brand: ${brandName}`);
    console.log(`Light file: ${lightFilePath}`);
    console.log(`Dark file: ${darkFilePath}`);

    if (fs.existsSync(lightFilePath) && fs.existsSync(darkFilePath)) {
      // Read the contents of both files
      const lightFileContent = fs.readFileSync(lightFilePath, "utf8");
      const darkFileContent = fs.readFileSync(darkFilePath, "utf8");

      // Log the contents of the light and dark token provider files
      console.log(`Light File Content:\n${lightFileContent}`);
      console.log(`Dark File Content:\n${darkFileContent}`);

      // Parse the SwiftUI and UIKit properties from each file
      const lightTokens = extractTokens(lightFileContent, "Color");
      const darkTokens = extractTokens(darkFileContent, "Color");
      const lightUITokens = extractTokens(lightFileContent, "UIColor");
      const darkUITokens = extractTokens(darkFileContent, "UIColor");

      // Combine the SwiftUI tokens into a single output
      const combinedSwiftUITokens = Object.keys(lightTokens).map(token => {
        const lightValue = lightTokens[token];
        const darkValue = darkTokens[token];
        return `    public var ${token}: Color { Color.dynamicColor(defaultColor: ${lightValue}, darkModeColor: ${darkValue}) }`;
      }).join("\n");

      // Combine the UIKit tokens into a single output
      const combinedUITokens = Object.keys(lightUITokens).map(token => {
        const lightValue = lightUITokens[token];
        const darkValue = darkUITokens[token];
        return `    public var ${token}: UIColor { UIColor.dynamicColor(defaultColor: ${lightValue}, darkModeColor: ${darkValue}) }`;
      }).join("\n");

      // Generate the combined file content
      const combinedContent = `import SwiftUI

// Generated by https://github.com/warp-ds/tokens
struct ${brandName}TokenProvider: TokenProvider {
${combinedSwiftUITokens}
}

struct ${brandName}UITokenProvider: UITokenProvider {
${combinedUITokens}
}
`;

      // Write the combined content to a new file
      const combinedFilePath = path.join(outputFolder, `${brandName}Tokens.swift`);
      fs.writeFileSync(combinedFilePath, combinedContent, "utf8");
      console.log(`Combined token provider created for ${brandName}`);

      // Delete the original Light and Dark token files
      fs.unlinkSync(lightFilePath);
      fs.unlinkSync(darkFilePath);
      console.log(`Deleted ${lightFile} and ${darkFile}`);
    } else {
      console.error(`Missing light or dark file for brand: ${brandName}`);
    }
  });
}

// Helper function to extract tokens from file content
function extractTokens(fileContent, type) {
  const tokenPattern = new RegExp(`public var (.+?): ${type} { (.+?) }`, "g");
  const tokens = {};
  let match;
  while ((match = tokenPattern.exec(fileContent)) !== null) {
    tokens[match[1]] = match[2];  // Capture token name and value
  }
  return tokens;
}

// Main function to generate all assets
export function generateSDAssets() {
  // First generate the colors for iOS (Brand Colors)
  generateColorsForIOS();

  // Then generate token provider for iOS
  generateTokenProviderForIOS();

  // Then generate the light tokens for iOS
  generateLightTokensForIOS();

  // Then generate the dark tokens for iOS
  generateDarkTokensForIOS();

  // Then generate the light colors for iOS
  generateLightColorsForIOS();

  // Then generate the dark colors for iOS
  generateDarkColorsForIOS();

  // Combine the LightTokenProvider and DarkTokenProvider files
  combineTokenProviders();

  // Preserve existing configuration for web, Android, and other platforms
  const tokensPath = "./tokens";
  const brandModes = fs
    .readdirSync(tokensPath)
    .filter((item) => fs.statSync(path.join(tokensPath, item)).isDirectory());

  brandModes.forEach((brandMode) => {
    const config = {
      source: [path.join(tokensPath, brandMode, "*.json")],
      platforms: {
        css: {
          transformGroup: "css",
          buildPath: `output/web/${brandMode}/`,
          files: [
            {
              destination: "variables.css",
              format: "css/variables",
              options: {
                outputReferences: true,
              },
            },
          ],
        },
        cssRgb: {
          transforms: [
            "attribute/cti",
            "name/cti/kebab",
            "time/seconds",
            "content/icon",
            "size/rem",
            "color/rgb",
          ],
          buildPath: `output/web/${brandMode}/`,
          files: [
            {
              destination: "variables-rgb.css",
              format: "css/variables",
              options: {
                outputReferences: true,
              },
            },
          ],
        },
        compose: {
          transformGroup: "compose",
          buildPath: `output/android/${brandMode}/`,
          files: [
            {
              destination: "StyleDictionaryColor.kt",
              format: "compose/object",
              className: "WarpColors",
              packageName: "com.schibsted.nmp.warp.theme",
            },
          ],
        },
      },
    };

    try {
      const sd = StyleDictionary.extend(config);
      sd.buildAllPlatforms();
      console.log(`Successfully built Style Dictionary for ${brandMode}`);
    } catch (error) {
      console.error(`Error building Style Dictionary for ${brandMode}: ${error.message}`);
    }
  });
}
